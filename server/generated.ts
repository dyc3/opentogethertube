/*
 Generated by typeshare 1.7.0
*/

export type ClientId = string;

export type RoomName = string;

export type MonolithId = string;

export interface B2MLoad {
	room: RoomName;
}

export interface B2MUnload {
	room: RoomName;
}

export interface B2MJoin {
	room: RoomName;
	client: ClientId;
	token: string;
}

export interface B2MLeave {
	client: ClientId;
}

export interface B2MClientMsg<T = unknown> {
	/** The client that sent the message. */
	client_id: ClientId;
	/** The message that was received from the client, verbatim. */
	payload: T;
}

export interface M2BInit {
	/** The port that the monolith is listening for HTTP requests on. */
	port: number;
	region: string;
}

export enum Visibility {
	Public = "public",
	Unlisted = "unlisted",
	Private = "private",
}

/** Metadata about a room, according to the Monolith. */
export interface RoomMetadata {
	name: RoomName;
	title: string;
	description: string;
	isTemporary: boolean;
	visibility: Visibility;
	queueMode: string;
	currentSource: unknown;
	/** The number of clients in this room. */
	users: number;
}

export interface M2BLoaded {
	room: RoomMetadata;
	/** A system-global epoch that is incremented every time a room is loaded or unloaded on any monolith. Used to determine which instance of a room is the oldest. */
	load_epoch: number;
}

export interface M2BUnloaded {
	name: RoomName;
}

export interface GossipRoom {
	room: RoomMetadata;
	load_epoch: number;
}

export interface M2BGossip {
	rooms: GossipRoom[];
}

/**
 * Wrapper around a message that should be sent to clients in a room. The payload is any value that can be serialized to JSON.
 *
 * ```rust
 * # use serde_json::value::RawValue;
 * # use ott_balancer_protocol::monolith::{MsgM2B, M2BRoomMsg};
 * let json = M2BRoomMsg {
 * room: "foo".into(),
 * client_id: None,
 * payload: serde_json::json!({}),
 * };
 *
 * let raw = M2BRoomMsg {
 * room: "foo".into(),
 * client_id: None,
 * payload: RawValue::from_string("{}".to_owned()).unwrap(),
 * };
 *
 * let msg = MsgM2B::from(json);
 * let msg = MsgM2B::from(raw);
 * ```
 */
export interface M2BRoomMsg<T = unknown> {
	/** The room to send the message to. */
	room: RoomName;
	/** The client to send the message to. If `None`, send to all clients in the room. */
	client_id?: ClientId;
	/** The message to send, verbatim. */
	payload: T;
}

export interface M2BKick {
	client_id: ClientId;
	reason: number;
}

export type MsgB2M =
	| { type: "load"; payload: B2MLoad }
	| { type: "unload"; payload: B2MUnload }
	| { type: "join"; payload: B2MJoin }
	| { type: "leave"; payload: B2MLeave }
	| { type: "client_msg"; payload: B2MClientMsg };

export type MsgM2B<T = unknown> =
	| { type: "init"; payload: M2BInit }
	| { type: "loaded"; payload: M2BLoaded }
	| { type: "unloaded"; payload: M2BUnloaded }
	| { type: "gossip"; payload: M2BGossip }
	| { type: "room_msg"; payload: M2BRoomMsg<T> }
	| { type: "kick"; payload: M2BKick };
